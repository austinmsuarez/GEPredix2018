#!/usr/bin/env groovy
@Library('devrel') _
def branchName = env.BRANCH_NAME
def complianceEnabled = true;
def pullRequest = env.CHANGE_ID
def pullTarget = env.CHANGE_TARGET
def repoName = "passport-predix-oauth"
def jobName = "SDK-passport-predix-oauth"
def quickstartScript = "NA"

pipeline { 
  agent {
    docker {
      image 'predixadoption/devrelprediximage:latest'
      label 'dind'
    }
  }
  environment {
    COMPLIANCEENABLED = true
    NPM_CREDS = credentials('NPM_CREDS')
    CF_AWS_CREDS = credentials('cf_aws_creds')
    DEVCLOUD_ARTIFACTORY_CREDS = credentials('devcloud_artifactory_creds')
    EXT_GITHUB_CREDS = credentials('external_git_creds')
  }
  parameters {
    string(name: 'BUILD', defaultValue: 'true', description: 'checkout, build, test and/or deploy')
    string(name: 'INCREMENT', defaultValue: 'none', description: 'increment version - patch | major | minor')
    string(name: 'INCREMENT_DEPENDENCIES', defaultValue: 'false', description: 'point at latest dependencies in develop')
    string(name: 'MERGE_MASTER', defaultValue: 'false', description: 'merge to master')
    string(name: 'RELEASE', defaultValue: 'false', description: 'release master to production')
    string(name: 'SMOKE_TEST', defaultValue: 'false', description: 'run smoketests in production')
  }
  stages {
    stage("Checkout" ) {
      steps {
        echo "The workspace is ${env.WORKSPACE}"	    
        script {
          echo 'Stage Checkout'
          sh """#!/bin/bash -e
          set -x
          pwd
          git status
          ls -al
          ls -al /root
          printenv
          """          
          internalrelease.checkoutPropelSharedLibrary()
        }
      }
      post {
        success {
          echo "Checkout stage completed successfully"
        }
        failure {
          echo "Checkout stage failed"
        }
      }
    }
    stage("Build, Test, and/or Deploy" ) {
      when {
        allOf { environment name: 'BUILD', value: 'true'; environment name: 'MERGE_MASTER', value: 'false';  environment name: 'INCREMENT', value: 'none'; environment name: 'INCREMENT_DEPENDENCIES', value: 'false';  environment name: 'RELEASE', value: 'false'; environment name: 'SMOKE_TEST', value: 'false'; }
      }
      steps {
        echo "The workspace is ${env.WORKSPACE}"	    
        script {
          echo 'Stage Build, Test, Deploy'
          // retain this if-else pattern even if the same code is currently run in each
          // condition, for future needs that may run different codes 
          if ( "${env.BRANCH_NAME}" != "master" ) {
            milestone()
            lock ("${repoName}-BUILD") {
              milestone()
              if ( internalrelease.buildDevelop(repoName, jobName, branchName) ) {
                echo "Time to trigger dependent jobs to see if we broke something that is using this project"
              }
            }
          }
          else {
            jsFunctions.buildJS(repoName);
          }  
        }
      }
      post {
        success {
          echo "Build, Test, Deploy stage completed successfully"
        }
        failure {
          echo "Build, Test, Deploy stage failed"
        }
      }
    }
    stage('MergeToDevelop') {
      when {
        environment name: 'CHANGE_TARGET', value: 'develop'
      }
      steps {
        script {
          echo 'Stage MergeToDevelop'
          internalrelease.mergeToDevelop()
        }           
      }
    }
    stage('IncrementVersion') {
      when {
        branch 'develop'
        environment name: 'INCREMENT', value: 'patch'
      }
      steps {
        script {
          echo 'Stage IncrementVersion - run this stage when ready to increment on develop'
          internalrelease.incrementVersion(repoName, env.INCREMENT)
        }
        
      }
      post {
        success {
          echo "IncrementVersion stage completed, time to trigger increment dependencies on dependent projects to point at my new version"
        }
        failure {
          echo "IncrementVersion stage failed"
        }
      }
    }
    stage('IncrementVersionInDependencies') {
      when {
        branch 'develop'
        environment name: 'INCREMENT_DEPENDENCIES', value: 'true'
      }
      steps {
        script {
          echo 'Stage IncrementVersionInDependencies - run this stage - when versions of dependencies have changed, to point at latest versio of that dependency'
          internalrelease.incrementDependencies(repoName)
        }
      }
      post {
        success {
          echo "IncrementVersionInDependencies stage completed successfully"
        }
        failure {
          echo "IncrementVersionInDependencies stage failed"
        }
      }
    }
    
    stage('MergeMaster') {
      when {
        branch 'develop'
        anyOf { environment name: 'MERGE_MASTER', value: 'true';  }
      }
      parallel {
        stage('MergeMaster-dependency1') {
          steps {
            script {
              echo "Time to trigger dependency jobs to ensure we point at latest version"
            }
          }
          post {
            success {
              echo "MergeMaster - dependency1 completed successfully"
            }
            failure {
              echo "MergeMaster - dependency1 failed"
            }
          }
        }
      }
      post {
        success {
          script {
            echo "Merge to Master dependencies completed successfully"
            lock ("${repoName}-MergeMaster-doWork") {
              echo "MergeMaster-doWork"
              internalrelease.mergeToMaster(repoName)
            }
          }
        }
        failure {
          echo "Merge to Master stage failed"
        }
      }
    }
    stage("Release, SmokeTest" ) {
      when {
        environment name: 'RELEASE', value: 'true'
      }
      parallel {
        stage('Release-init') {
          steps {
            script {
              if ( "${env.BRANCH_NAME}" != "master" ) {
                echo "exiting, branchName should be master"
                error("Release phase should be run from master branch")
              }
            }
          }
          post {
            success {
              echo "Release - init completed successfully"
            }
            failure {
              echo "Release - init failed"
            }
          }
        }
        
      }
      post {
        success {
          script {
            echo "Release parallel dependencies completed successfuly"
            lock ("${repoName}-Release-doWork") {
              echo "Publishing passport-predix-oauth to NPMJS.COM"
              jsFunctions.npmPredixPublish(repoName)
              echo "Publishing passport-predix-oauth to GitHub.COM"
              externalrelease.releaseToGithub(repoName)
              env.SMOKE_TEST='true'
              echo "Release completed successfuly"
            }
          }
        }
        failure {
          echo "Release stage failed"
        }
      }
    }
    
    
    stage('SmokeTest') {
      when {
        environment name: 'SMOKE_TEST', value: 'true'
      }
      steps {
        script {
          if ( "${env.BRANCH_NAME}" != "master" ) {
            echo "exiting, branchName should be master"
            error("SmokeTest phase should be run from master branch")
          }

          if ( params.containsKey("POPS") ) {
            def popsArray = params.POPS.split(',')
            def instancePrepender = "smoke-${INSTANCE_PREPENDER}"
            externalrelease.smokeTestWithQuickstart(repoName, jobName , popsArray, quickstartScript, "${params.MORE_SWITCHES}", instancePrepender, "master", "mvn_settings_external.xml")
          }
          else {
            //if microservice login
            cloudFoundry.loginToUSW()
            externalrelease.smokeTest(repoName, false, true)
          }
        }
      }
      post {
        success {
          echo "SmokeTest stage completed successfuly"
        }
        failure {
          echo "SmokeTest stage failed"
        }
        always {
          script {
            notifications.sendMail()
          }
        }
      }
    }
  }
  post {
    always {
      script {
        internalrelease.cleanupAfterJob()
        notifications.sendFlowdockMsg()
      }
    }
  }
}
