#!/bin/bash
set -e
set -x

GIT_USER=""
GIT_PASSWORD=""
GIT_URL=""
GIT_BRANCH=""
IGNORE_VERSION=false
echo "args=$@"

while getopts ":u:p:g:b:v:m:" opt; do
  case "$opt" in
	u)
		GIT_USER="$OPTARG"
	;;
	p)
		GIT_PASSWORD="$OPTARG"
	;;
	g)
	  GIT_URL="$OPTARG"
	;;
	b)
	  GIT_BRANCH="$OPTARG"
	;;
	q)
	  QQQ="$OPTARG"
	;;
	v)
	  VERSION="$OPTARG"
	;;
	m)
	  MVN_SETTINGS="$OPTARG"
	;;

	# ? means invalid flag was passed.
	\?)
    	echo "Invalid option: ${bold}-$OPTARG${normal}" >&2
    	exit 1
  ;;
  :)
  	echo "The -$OPTARG option requires an argument"
  	exit 1
	;;
  esac
done

if [[ "$GIT_USER" = "" ]] || [[ "$GIT_PASSWORD" = "" ]] || [[ "$GIT_URL" = "" ]]; then
  echo "You must pass a username (-u), password (-p) and url (-g) to migrate to external git using the specified flags."
  echo "Example: $0 -u owen-ge -p LoveThisJob -g http://github.build.ge.com/<Org>/<RepoName> -b <Branch>"
  exit 1
fi

RESULT=$(git ls-remote --heads $GIT_URL $GIT_BRANCH | wc -l | awk '{print $1}')
if [[ $RESULT == "0" ]]; then
  echo "Ignoring: Branch $GIT_BRANCH not found for repo $GIT_URL"
  exit 0
fi

echo "Migrating $REPO_NAME..."
if [[ "$GIT_BRANCH" = "" ]]; then
	GIT_BRANCH="master"
fi

pwd
echo "Cloning $GIT_URL..."
REPO_NAME=$(echo $GIT_URL | awk -F"/" '{print $5}' | awk -F"." '{print $1}')
git clone --branch $GIT_BRANCH $GIT_URL $REPO_NAME-$GIT_BRANCH

if [ -e ./.gitmodules ]; then
  echo "Updating git submodules..."
  #git submodule update --recursive --remote
  
  #cp .gitmodules .gitmodules_orig
  #cp scripts/.gitmodules_master .gitmodules
  #git submodule init
  #git submodule update --rebase --remote
  #./scripts/pullSubModules.sh
  #mv .gitmodules_orig .gitmodules
fi

#clone from external git
REMOTE_URL="https://$GIT_USER:$GIT_PASSWORD@github.com/PredixDev/$REPO_NAME"
echo "Cloning $REMOTE_URL..."
rm -rf $REPO_NAME-$GIT_BRANCH-external
git clone --branch $GIT_BRANCH $REMOTE_URL $REPO_NAME-$GIT_BRANCH-external

pushd $REPO_NAME-$GIT_BRANCH-external
  git rm -r *
  cp -R ../$REPO_NAME-$GIT_BRANCH/* .
  ghPagesExternal=`git ls-remote --heads 2>/dev/null |awk -F 'refs/heads/' '{print $2}' | grep gh-pages | wc -l`
 
  echo "ghPagesExternal=$ghPagesExternal"
popd

ghPagesInternal=`git ls-remote --heads 2>/dev/null |awk -F 'refs/heads/' '{print $2}' | grep gh-pages | wc -l`
echo "ghPagesInternal=$ghPagesInternal"

#delete internal git clone
#rm -rf $REPO_NAME-$GIT_BRANCH

echo "Tagging and releasing..."
pushd $REPO_NAME-$GIT_BRANCH-external
  pwd

  # Clean up! Remove files that point to internal GE resources
  find . -name mvn_settings.xml -delete
  find . -name "manifest\-*.yml" -delete
  find . -name "Jenkinsfile" -delete
  if [ -e ./.gitmodules ]; then
    git submodule deinit -f .
    for path in $(git config --file .gitmodules  --get-regexp path | awk '{print $2}'); do
      git rm $path
    done
    git commit -m 'remove old submodules'
    for path in $(git config --file scripts/.gitmodules_external  --get-regexp path | awk '{print $2}'); do
      rm -rf $path
    done
    for url in $(git config --file scripts/.gitmodules_external  --get-regexp url | awk '{print $2}'); do
      git submodule add $url
    done
  fi
  if [ -e ./scripts/release.sh ]; then
    echo "Running ./scripts/release.sh..."
    chmod +x ./scripts/release.sh
    /bin/bash -x -c ./scripts/release.sh
    rm -f ./scripts/release.sh
  fi

  for d in */; do
    # Will print */ if no directories are available
    echo "$d"
    cd $d
    if [[ -e scripts/release.sh ]]; then 
      chmod +x scripts/release.sh
      scripts/release.sh
    fi
    cd ..
  done

  if [ -e ./release.sh ]; then
    echo "Running ./release.sh..."
    chmod +x ./release.sh
    /bin/bash -x -c ./release.sh
    rm -f ./release.sh
  fi

  export IGNORE_VERSION
  pwd
  ../library/scripts/checkErrors.sh


  # Reading VERSION
  pwd
  #VERSION=$("../library/scripts/version.sh")
  #VERSIONSTATUS=$?
  #echo "Status=$VERSIONSTATUS"
  echo "Version=$VERSION"
  if [ "$VERSIONSTATUS" == "1" ]; then
    echo ""
    echo "version file not found or is misconfigured"
    exit 1
  fi

  echo "git status"
  git status
  git add .
  git status
  commitsFound=`git status | grep -E 'Your branch is ahead|Changes to be committed|Changes not staged for commit' | wc -l`
  echo "commitsFound=$commitsFound"
  SKIP_COMMIT=false

  if [ "$commitsFound" -eq "0" ]; then
  echo "********************************************************************************"
  echo "no changes found, exiting this function."
  echo "********************************************************************************"
  exit 0
  fi

  if [ -e pom.xml ]; then
    echo "releaseToArtifactoryMaven"
    if [ ! -e .gitmodules ]; then 
      mvn -DskipTests -Dpredix.rest.useProxyPropertiesFromFile=false -B -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -DaltDeploymentRepository=predix.repo::default::https://artifactory.predix.io/artifactory/PREDIX-EXT clean source:jar javadoc:jar deploy -s $MVN_SETTINGS
    fi
    echo "releaseToArtifactoryMaven complete"
  fi
  
  if [ -n "$(git status --untracked-files=no --porcelain)" ]; then
    echo "commiting"
    LAST_COMMIT=$(git --no-pager log -1 --pretty='format:%s')
    if [[ "$LAST_COMMIT" = "Release $VERSION" ]]; then
      git status
      git commit --amend --no-edit
      git push -f --set-upstream origin master
    else
      git commit -a -m "Release $VERSION"
      git push --set-upstream origin master
    fi    
  else
   echo "nothing to commit"
  fi
  echo "git push master complete"
  git status

popd

#now handle gh-pages, if it exists
if [ "$ghPagesInternal" -gt "0" ]; then
  git clone --branch gh-pages $GIT_URL $REPO_NAME-gh-pages

  if [ "$ghPagesExternal" -gt "0" ]; then
    git clone --branch gh-pages $REMOTE_URL $REPO_NAME-gh-pages-external
  else
    #first time push, need to create gh-pages branch
    git clone $REMOTE_URL $REPO_NAME-gh-pages-external
    pushd $REPO_NAME-gh-pages-external
      git checkout -b gh-pages
      echo "$REPO_NAME" > README.md
      git add README.md
      git commit -am "new gh-pages branch"
      git push origin gh-pages --force
    popd
  fi
  #copy and commit any changes to gh-pages
  pushd $REPO_NAME-gh-pages-external
    git rm -r *
    cp -R ../$REPO_NAME-gh-pages/* .
    git add .
    git status
    commitsFoundGHPages=`git status | grep -E 'Your branch is ahead|Changes to be committed|Changes not staged for commit' | wc -l`
    echo "commitsFoundGHPages=$commitsFoundGHPages"
    if [ "$commitsFoundGHPages" -gt "0" ]; then
      git commit -a -m "Release $VERSION"
      git push -u origin gh-pages
    else
      echo "no gh-pages changes found"
    fi
    git status
  popd
fi

pushd $REPO_NAME-$GIT_BRANCH-external

  echo "ready to git tag" 
  git tag $VERSION
  echo "git tag complete"
  git push --tags

  # add a call to release API
  RELEASE_REPO_URI=https://api.github.com/repos/PredixDev/$REPO_NAME/releases
  echo ""
  echo "Releasing Repo "$RELEASE_REPO_URI with tag version $VERSION
  export RELEASE_API_JSON=$(printf '{"tag_name": "%s","target_commitish": "master","name": "%s","body": "Release of version %s","draft": false,"prerelease": false}' $VERSION $VERSION $VERSION)
  echo $RELEASE_API_JSON
  #curl -u $GIT_USER:$GIT_PASSWORD --data "$RELEASE_API_JSON" $RELEASE_REPO_URI
  #curl --write-out %{http_code} -u $GIT_USER:$GIT_PASSWORD --data "$RELEASE_API_JSON" $RELEASE_REPO_URI
  export responseCurl=$( curl --write-out %{http_code} --output /dev/null -u $GIT_USER:$GIT_PASSWORD --data "$RELEASE_API_JSON" $RELEASE_REPO_URI )
  echo responseCurl=$responseCurl
  # check status of the response to determine the error
  if [ "$responseCurl" == "200" ] || [ "$responseCurl" == "201" ]; then
    echo "All good"
  else
    echo "Build failed for $GITHUB_REPO when trying to create github Release via API"
    exit 1
  fi

  echo "**********************************************"
  echo "Released Repo $RELEASE_REPO_URI with tag version $VERSION"
  echo "**********************************************"

popd
